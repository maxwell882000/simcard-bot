const { Telegraf } = require('telegraf')
const LocalSession = require('telegraf-session-local')
const Markup = require('telegraf/markup')
const Stage = require('telegraf/stage')
const Scene = require('telegraf/scenes/base')
let Screens = require('./screens')

const helpers = require('./helpers')

// registration
const registerScene = new Scene('register')
registerScene.enter(async (ctx) => {
    if (ctx.from.id == process.env.TELEGRAM_ADMIN) {
        ctx.session.superuser = true
    }
    ctx.session.username = ctx.from.username

    if (ctx.session.name) {
        await ctx.reply('–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!\n–ö–æ–º–ø–∞–Ω–∏—è Happytel –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –í–∞—Åü§ó. –°–ø–∞—Å–∏–±–æ –∑–∞ –í–∞—à –≤—ã–±–æ—Äüòä', Markup.keyboard(['–°–≤—è–∑–∞—Ç—å—Å—è —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º']).resize().extra())
        await ctx.scene.enter('menu')
    } else {
        await ctx.scene.enter('name')
    }
})

const nameScene = new Scene('name')
nameScene.enter((ctx) => {
    ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –≤–∞—à–µ –∏–º—è', Markup.keyboard([ctx.chat.first_name
        + ' ' + (ctx.chat.last_name || '')]).resize().extra())
})
nameScene.on('text', (ctx) => {
    ctx.session.name = ctx.message.text
    ctx.scene.enter('phone')
})

const phoneScene = new Scene('phone')
phoneScene.enter((ctx) => {
    ctx.reply('–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞',
        Markup.keyboard([Markup.contactRequestButton('–û—Å—Ç–∞–≤–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç')]).resize().extra())
})
phoneScene.on('contact', async (ctx) => {
    ctx.session.phone = ctx.message.contact.phone_number
    await ctx.reply('–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!\n–ö–æ–º–ø–∞–Ω–∏—è Happytel –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –í–∞—Åü§ó. –°–ø–∞—Å–∏–±–æ –∑–∞ –í–∞—à –≤—ã–±–æ—Äüòä', Markup.keyboard(['–°–≤—è–∑–∞—Ç—å—Å—è —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º']).resize().extra())
    await ctx.scene.enter('menu')
})
phoneScene.on('text', async (ctx) => {
    ctx.session.phone = ctx.message.text
    await ctx.reply('–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!\n–ö–æ–º–ø–∞–Ω–∏—è Happytel –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –í–∞—Åü§ó. –°–ø–∞—Å–∏–±–æ –∑–∞ –í–∞—à –≤—ã–±–æ—Äüòä', Markup.keyboard(['–°–≤—è–∑–∞—Ç—å—Å—è —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º']).resize().extra())
    await ctx.scene.enter('menu')
})

// android menu
const androidScene = new Scene('android')
androidScene.enter(async (ctx) => {
    let msg = await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à–µ —É—Å—Ç—Ä–æ–π—Å—Ç–æ',
        Markup.inlineKeyboard([[
            Markup.callbackButton('Meizu', 'meizu'),
            Markup.callbackButton('Samsung/LG', 'samsunglg')
        ], [
            Markup.callbackButton('–ù–∞–∑–∞–¥', 'back')
        ]]).extra())
    ctx.session.deleteMsg = msg.message_id
})
androidScene.action(/meizu|samsunglg|xiaomi/, async (ctx) => {
    ctx.session.device = ctx.callbackQuery.data
    let msg = await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏',
        Markup.inlineKeyboard([
            Markup.callbackButton('APN', 'apn'),
            Markup.callbackButton('–†–æ—É–º–∏–Ω–≥', 'roaming'),
        ]).extra())
    ctx.session.deleteMsg = msg.message_id
})
androidScene.action(/apn|roaming/, async (ctx) => {
    ctx.session.method = ctx.callbackQuery.data
    delete ctx.session.step // clear step before entering
    await ctx.scene.enter(ctx.session.device + '_' + ctx.session.method)
})
androidScene.action('back', async (ctx) => {
    await ctx.scene.enter('menu')
})

// ios menu
const iosScene = new Scene('ios')
iosScene.enter(async (ctx) => {
    ctx.session.device = 'ios'
    let msg = await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏',
        Markup.inlineKeyboard([[
            Markup.callbackButton('APN', 'apn'),
            Markup.callbackButton('–†–æ—É–º–∏–Ω–≥', 'roaming'),
        ], [
            Markup.callbackButton('–ù–∞–∑–∞–¥', 'back')
        ]]).extra())
    ctx.session.deleteMsg = msg.message_id
})
iosScene.action(/apn|roaming/, async (ctx) => {
    ctx.session.method = ctx.callbackQuery.data
    delete ctx.session.step // clear step before entering
    await ctx.scene.enter(ctx.session.device + '_' + ctx.session.method)
})
iosScene.action('back', async (ctx) => {
    await ctx.scene.enter('menu')
})

// menu
const menuScene = new Scene('menu')
let sendMenu = async (ctx, id) => {
    let msg = await ctx.telegram.sendMessage(id, '–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω—É—é —Å–∏—Å—Ç–µ–º—É –í–∞—à–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞',
        Markup.inlineKeyboard([
            Markup.callbackButton('Android', 'android'),
            Markup.callbackButton('iOS', 'ios')
        ]).extra())
    ctx.session.deleteMsg = msg.message_id
    // handle admin with helpers.getSession
} // save this function to use later
menuScene.enter(async (ctx) => {
    await sendMenu(ctx, ctx.from.id)
})
menuScene.action(/android|ios/, async (ctx) => {
    await ctx.scene.enter(ctx.callbackQuery.data)
})

// setup bot and sessions
const bot = new Telegraf(process.env.TELEGRAM_TOKEN)
bot.use((new LocalSession({
    database: 'sessions.json',
    getSessionKey: function (ctx) {
        return ctx.from.id
    } // only user session handling
})).middleware())

const meizuApn = new Screens('meizu_apn', 4, [
    '–ü–µ—Ä–≤—ã–π —à–∞–≥: SIM-–∫–∞—Ä—Ç—ã –∏ —Å–µ—Ç–∏',
    '–í—Ç–æ—Ä–æ–π —à–∞–≥: –¢–æ—á–∫–∞ –¥–æ—Å—Ç—É–ø–∞ (APN)',
    '–¢—Ä–µ—Ç–∏–π —à–∞–≥: –î–æ–±–∞–≤–∏—Ç—å APN',
    '–ß–µ—Ç–≤–µ—Ä—Ç—ã–π —à–∞–≥: –í–≤–µ—Å—Ç–∏ APN –∏ –ò–º—è (internet, internet)'])
const meizuRoaming = new Screens('meizu_roaming', 3, [
    '–ü–µ—Ä–≤—ã–π —à–∞–≥: SIM-–∫–∞—Ä—Ç—ã –∏ —Å–µ—Ç–∏',
    '–í—Ç–æ—Ä–æ–π —à–∞–≥: –ò–Ω—Ç–µ—Ä–Ω–µ—Ç-—Ä–æ—É–º–∏–Ω–≥',
    '–¢—Ä–µ—Ç–∏–π —à–∞–≥: –ù—É–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ —Ä–æ—É–º–∏–Ω–≥–µ'])
const iosApn = new Screens('ios_apn', 3, [
    '–ü–µ—Ä–≤—ã–π —à–∞–≥: –°–æ—Ç–æ–≤–∞—è —Å–≤—è–∑—å',
    '–í—Ç–æ—Ä–æ–π —à–∞–≥: –ó–∞—Ö–æ–¥–∏–º –≤ —Å–æ—Ç–æ–≤–∞—è —Å–µ—Ç—å –∏ –ø–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö',
    '–¢—Ä–µ—Ç–∏–π —à–∞–≥: –£–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ APN - internet'
])
const iosRoaming = new Screens('ios_roaming', 5, [
    '–ü–µ—Ä–≤—ã–π —à–∞–≥: –°–æ—Ç–æ–≤–∞—è —Å–≤—è–∑—å',
    '–í—Ç–æ—Ä–æ–π —à–∞–≥: –°–æ—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ',
    '–¢—Ä–µ—Ç–∏–π —à–∞–≥: –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–∞–Ω–Ω—ã—Ö',
    '–ß–µ—Ç–≤–µ—Ä—Ç—ã–π —à–∞–≥: –†–æ—É–º–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö',
    '–ü—è—Ç—ã–π —à–∞–≥: –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º LTE'])
const samsungLgApn = new Screens('samsunglg_apn', 6, [
    '–ü–µ—Ä–≤—ã–π —à–∞–≥: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏—è',
    '–í—Ç–æ—Ä–æ–π —à–∞–≥: –ú–æ–±–∏–ª—å–Ω—ã–µ —Å–µ—Ç–∏',
    '–¢—Ä–µ—Ç–∏–π —à–∞–≥: –¢–æ—á–∫–∞ –¥–æ—Å—Ç—É–ø–∞',
    '–ß–µ—Ç–≤–µ—Ä—Ç—ã–π —à–∞–≥: –î–æ–±–∞–≤–∏—Ç—å',
    '–ü—è—Ç—ã–π —à–∞–≥: –í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ç–æ—á–∫—É –¥–æ—Å—Ç—É–ø–∞ (internet, internet)',
    '–®–µ—Å—Ç–æ–π —à–∞–≥: –°–æ—Ö—Ä–∞–Ω–∏—Ç—å'
])
const samsungLgRoaming = new Screens('samsunglg_roaming', 6, [
    '–ü–µ—Ä–≤—ã–π —à–∞–≥: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏—è',
    '–í—Ç–æ—Ä–æ–π —à–∞–≥: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö',
    '–¢—Ä–µ—Ç–∏–π —à–∞–≥: –í–∫–ª—é—á–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–æ–±–∏–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö',
    '–ß–µ—Ç–≤–µ—Ä—Ç—ã–π —à–∞–≥: –í–µ—Ä–Ω–∏—Ç–µ—Å—å –Ω–∞–∑–∞–¥',
    '–ü—è—Ç—ã–π —à–∞–≥: –ú–æ–±–∏–ª—å–Ω—ã–µ —Å–µ—Ç–∏',
    '–®–µ—Å—Ç–æ–π —à–∞–≥: –í–∫–ª—é—á–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤ —Ä–æ—É–º–∏–Ω–≥–µ'
])

// setup scenes
const stage = new Stage([registerScene, nameScene, phoneScene, menuScene, androidScene, iosScene,
    meizuApn, meizuRoaming, samsungLgApn, samsungLgRoaming, iosApn, iosRoaming])
bot.use(async (ctx, next) => {
    try {
        await ctx.deleteMessage(ctx.session.deleteMsg)
    } catch (e) { }
    return next() // pass through
}) // delete old inline message
bot.use(stage.middleware())
bot.start((ctx) => ctx.scene.enter('register'))

bot.catch((err, ctx) => {
    console.log(err) // unhandled errors (known: connected user blocked bot)
    ctx.reply('–í–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞, –Ω–∞–±–µ—Ä–∏—Ç–µ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ /start')
})

// handle global commands, actions, messages
bot.command('addadmin', async (ctx) => {
    if (ctx.session.superuser) {
        let parts = ctx.message.text.split(' ')
        let username = parts[1]
        let user = ctx.sessionDB.get('sessions').find((s) => s.data.username == username).value()
        if (user) {
            user.data.admin = true
            helpers.saveSession(ctx.sessionDB, user.id, user.data)
            ctx.reply('–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –∑–∞—Ä–µ–≥–µ—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω')
        } else {
            ctx.reply('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω')
        }
    } else {
        ctx.reply('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤')
    }
})

// listen callback query starting with connect
bot.action(/connect/, async (ctx, next) => {
    // auth
    if (!ctx.session.admin && !ctx.session.superuser) {
        await ctx.telegram.sendMessage(ctx.from.id, '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤')
        return next() // pass through
    }
    // ctx.from.id - admin, callbackQuery.data - user
    let user = ctx.callbackQuery.data.substring(8)
    // change message if connected
    let me = await ctx.telegram.getMe()
    let keyboard = Markup.inlineKeyboard([
        Markup.urlButton('–ü–µ—Ä–µ–π—Ç–∏ –∫ –±–æ—Ç—É', 'https://t.me/' + me.username)
    ]).extra()

    // try edit msg on client
    try {
        await ctx.telegram.editMessageText(process.env.TELEGRAM_NOTIFICATIONS,
            ctx.session.notificationId, null, ctx.session.notification + '\n\n–°—Ç–∞—Ç—É—Å: –í –ø—Ä–æ—Ü–µ—Å—Å–µ', keyboard)
    } catch (e) {}

    let endDialog = Markup.keyboard(['–ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥']).resize().extra()
    // set conversation of admin
    ctx.session.conversation = user
    await ctx.telegram.sendMessage(ctx.from.id, '–í—ã –Ω–∞—á–∞–ª–∏ –æ–±—â–µ–Ω–∏–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º', endDialog)
    // set conversation of user
    let session = await helpers.getSession(ctx.sessionDB, user)
    session.conversation = ctx.from.id
    await helpers.saveSession(ctx.sessionDB, user, session)
    await ctx.telegram.sendMessage(user, '–û–ø–µ—Ä–∞—Ç–æ—Ä –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è', endDialog)
    // try edit msg on conversation user
    try {
        await ctx.telegram.editMessageText(process.env.TELEGRAM_NOTIFICATIONS,
            session.notificationId, null, session.notification + '\n\n–°—Ç–∞—Ç—É—Å: –í –ø—Ä–æ—Ü–µ—Å—Å–µ', keyboard)
    } catch (e) {}
    // end
    await ctx.answerCbQuery()
})
bot.hears('–ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥', async (ctx) => {
    // check in which session notification is stored, then edit
    tryCloseNotification = async (session) => {
        if (session.notificationId) {
            try {
                await ctx.telegram.editMessageText(process.env.TELEGRAM_NOTIFICATIONS,
                    session.notificationId, null, session.notification + '\n\n–°—Ç–∞—Ç—É—Å: –ó–∞–≤–µ—Ä—à–µ–Ω',
                    { reply_markup: null })
                delete session.notificationId
                delete session.notification
            } catch (e) {} // prevent editing/deleting error
        }
    }

    if (ctx.session.conversation) {
        // clear conversation user (HACK with manual scene.enter)
        let user = ctx.session.conversation
        await ctx.telegram.sendMessage(ctx.session.conversation, '–î–∏–∞–ª–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω', Markup.keyboard(['–°–≤—è–∑–∞—Ç—å—Å—è —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º']).resize().extra())
        let session = await helpers.getSession(ctx.sessionDB, user)
        await tryCloseNotification(session)
        delete session.conversation
        session['__scenes'].current = 'menu' // set current scene to menu
        await helpers.saveSession(ctx.sessionDB, user, session)
        await sendMenu(ctx, user) // and send it
        // clear self
        await ctx.reply('–î–∏–∞–ª–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω', Markup.keyboard(['–°–≤—è–∑–∞—Ç—å—Å—è —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º']).resize().extra())
        delete ctx.session.conversation
        await tryCloseNotification(ctx.session)
        await ctx.scene.enter('menu')
    }
})
bot.hears('–°–≤—è–∑–∞—Ç—å—Å—è —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º', async (ctx) => {
    let text = `–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${ctx.session.name}\n–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞: ${ctx.session.phone}\n`
    if (ctx.from.username) {
        text += `–Æ–∑–µ—Ä–Ω–µ–π–º @${ctx.from.username}\n`
    }
    let keyboard = Markup.inlineKeyboard([
        Markup.callbackButton('–û—Ç–≤–µ—Ç–∏—Ç—å', 'connect:' + ctx.from.id) // save user id
    ]).extra()
    await ctx.reply('–ñ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞') // to user
    let msg = await ctx.telegram.sendMessage(process.env.TELEGRAM_NOTIFICATIONS, text, keyboard)
    ctx.session.notificationId = msg.message_id
    ctx.session.notification = msg.text
})
bot.on('text', async (ctx, next) => {
    if (ctx.session.conversation) { // has conversation with operator/user
        return ctx.telegram.sendMessage(ctx.session.conversation, ctx.message.text)
    } else {
        return next() // pass through
    }
})

module.exports = bot
